/**************
FILE          : HPCControl.ycp
***************
PROJECT       : YaST2 - Yet another Setup Tool
              :
AUTHOR        : Thomas Hofmann <thofmann@suse.de>
              :
BELONGS TO    : YaST2 - HPC Setup Module
              :
DESCRIPTION   : A module for setting up a HPC-Cluster-Scheduling System
              : with necessary environment
              :
STATUS        : Development
**************/
/*! \brief YaST2 - HPC interface (UI part)
*
* File:        HPCControl.ycp
* Package:     hpc Configuration
* Summary:     Main Module started if yast2 hpc is called
* Authors:     Thomas Hofmann <thofmann@suse.de>
*/
{ //begin
module "HPCControl";

textdomain "hpc";

import "Package";
import "Service";



//------------------------------------------
// check required Packages and install...
//------------------------------------------
global define any installPackages( list<string> requiredPacs )
``{
        return Package::InstallAllMsg (
                requiredPacs, _("There are packages missing! \n Do you want to install these packages ?")
        ) ? `auto : nil;
};



//---------------------------------------------
// check required services if running
//---------------------------------------------

global define boolean HPCServiceCheck( string service )
``{

        integer status = Service::Status ( service );
y2milestone ("status is %1", status);
	// return true if service is running
        if ( status == 0 )
        {
	return true;
        }
	else return false;
};


//---------------------------------------------
// restart required services
//---------------------------------------------

global define boolean HPCServiceRestart( string service )
``{

        boolean start = Service::Restart ( service );

        // return true if service is running
        if ( start == true )
        {
        return true;
        }
        else return false;
};


//---------------------------------------------
// start required services
//---------------------------------------------

global define boolean HPCServiceStart( string service )
``{

        boolean start = Service::Start ( service );

	// return true if service is running
        if ( start == true )
        {
	return true;
        }
	else return false;
};

/*
//-------------------------------------------------
// Create Queue Tree-Term
//-------------------------------------------------
global define term HPCQueueTree()
{
	term ret= `VBox(
			`Tree(	`id(`queue),
				`opt(notify),
				_("Available Queues:"),
				HPCControl::Queuelist()
			     ),
			`HBox(
				`PushButton(`id(`create), _("Create Queue")),
				`PushButton(`id(`delete), _("Delete Queue"))
			     )
		     );
	return ret;
};



//-------------------------------------------------
// Create Queue list (item list)
//-------------------------------------------------
global define list Queuelist()
{
	`item(),""

};



*/










//-----------------------------------------------------------------
// load configure-files for MultiLineEdit - Advanced Mode
//-----------------------------------------------------------------

// Read Queue Configuration from QMGR

global define string HPCQueueConfig()
``{
	string qconfig = nil;

	if (SCR::Execute (.target.bash, "/opt/pbs/bin/qmgr -c \042 print server \042 > /tmp/queue.conf") == 0)
		{
		qconfig = (string)SCR::Read (.target.string, "/tmp/queue.conf");

		SCR::Execute (.target.bash, "rm -rf /tmp/queue.conf");
//		y2milestone ("... qconfig read and deleted ...");
		}

	else
		{
		// qconfig = nil;

		}

	return qconfig;

};


// Read Scheduler Configuration from file

global define string HPCSchedConfig()
``{
	string schedconfig = nil;

	if (SCR::Execute (.target.bash, "/usr/bin/test -e /var/spool/pbs/sched_priv/sched_config") == 0)
		{
		schedconfig = (string)SCR::Read (.target.string, "/var/spool/pbs/sched_priv/sched_config");

//		y2milestone ("... sched_config read ...");
		}

//	else { y2milestone ("... reading failed ...");}

	return schedconfig;

};

// Write Scheduler Configuration from file

global define void HPCwriteSchedConfig( string configtext )
``{
        SCR::Write (.target.string, "/var/spool/pbs/sched_priv/sched_config", configtext);
        HPCControl::HPCServiceRestart("pbs_sched");
	//TODO  Return failed if service does not start
};


//-----------------------------------------------------------------
// detect Queue Properties & Kind of Configure (Simple / Advanced)
//-----------------------------------------------------------------

global define list getQProperties()
{
	list properties = nil;

	string SQName = _("not available");

	string SQWalltime = _("not available");

	string PQName = _("not available");

	string PQWalltime = _("not available");

	string PQNodes = _("not available");
/*
	if ( HPCQueueConfig() == nil )
	{
	map out = (map)SCR::Execute (.target.bash_output, "/opt/pbs/bin/qmgr -c \042 print server \042 > /tmp/queue.conf");
        string error = (string)out["stderr"]:nil;
        UI::OpenDialog(
                        `VBox(	`Label(_("The Following Error caused the installation to abort:")),
				`Label(error),
				`PushButton("&Abort Installation")
                             )
                      );

	UI::UserInput();
	break;
	y2milestone ("--------error-loop--------");
	UI::CloseDialog();
	};
*/
	properties = [ SQName, SQWalltime, PQName, PQWalltime, PQNodes ];
	return properties;


};




global define any getUserSkills()
{
	list userskill = nil;
	return userskill;
};

//-----------------------------------------
// Check if User made changes
//-----------------------------------------

global define boolean have_changes_check()
{
	boolean status = true;
        return status;
};


//-----------------------------------------------------------------
// detect configure-files for ComboBox - Advanced Mode
//-----------------------------------------------------------------

global define any comboboxfiles()
{
	list filestoedit = nil;
	filestoedit =	[`item(`id(`sched), _("Scheduler Configuration") ),
			 `item(`id(`queue), _("Queue Configuration"), true )
			];
	return filestoedit;
};


//-----------------------------------------------------------------
// collect information about nodes 
//-----------------------------------------------------------------

// Collect information by querying IPs

// get name from IP
global define string name(string ip)
{
	string command = ("/usr/lib/YaST2/bin/nodes_ip.sh name "+ip);
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"n.a.", "}\n" );
	return ret;
};

// determine if computer is member of cluster
global define string clusternode(string resname)
{
	string command = ("/usr/lib/YaST2/bin/nodes_ip.sh clusternode "+resname);
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"n.a.", "\n" );
	return ret;
};

// get number of cpus of node $
global define string cpus(string resname)
{
	string command = "/usr/lib/YaST2/bin/nodes_ip.sh cpus "+resname;
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"n.a.", "\n" );
	return ret;

};

// get status of node
global define string status(string resname)
{
	string command = "/usr/lib/YaST2/bin/nodes_ip.sh status "+resname;
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"not reachable", "\n" );
	return ret;
};



// Collect information by querying 'pbsnodes -a'

// get status of node
global define string ipaddress(string resname)
{
	string command = "/usr/lib/YaST2/bin/nodes_hpc.sh ip "+resname;
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars(  (string)output["stdout"]:"n.a.", "\n" );
	return ret;
};



//-----------------------------------------------------------------
// detect Content of Nodes Table
//-----------------------------------------------------------------

global define list nodesIP()
{
// TODO: in case of error: should return Label "No PBS detected" or something lk that

	string command = "/usr/lib/YaST2/bin/nodes_ip.sh broadcast";
	map output =(map) SCR::Execute(.target.bash_output, command);
        string ipaddr = (string)output["stdout"]:"";
	y2milestone("ipaddr vor splitting %1", ipaddr);
        list<string> iplist = splitstring(ipaddr,"\n");
	y2milestone("ipaddr nach splitting %1", iplist);

        integer tableID = 1;
        list table = [];
        foreach(string ip, iplist, ``{
                if (ip != "")
                {
                string cname = name(ip);
                list row = [`item(`id(tableID),
                                ip,
                                clusternode(cname),
                                cname,
                                cpus(cname),
                                status(cname)
                        )];
                table = union(table,row);
                y2milestone("foreach id : %1 name: %2",tableID, ip);
                tableID = tableID+1;
                }
        });
        y2milestone("table : %1", table);

        return table;
//      return tableitems;

};



global define list nodesHPC()
{
// TODO: in case of error: should return Label "No PBS detected" or something lk that

        string command = "/usr/lib/YaST2/bin/nodes_hpc.sh clusternodes";
        map output = (map)SCR::Execute(.target.bash_output, command);
        string nodes = (string)output["stdout"]:"";
	y2milestone("nodes vor splitting %1", nodes);
        list<string> nodelist = splitstring(nodes,"\n");
	y2milestone("nodes nach splitting %1", nodelist);

        integer tableID = 1;
        list table = [];
        foreach(string node, nodelist, ``{
                if (node != "")
                {
                string ip = ipaddress(node);
                list row = [`item(`id(tableID),
                                ip,
                                "yes",
                                node,
                                cpus(node),
                                status(node)
                        )];
                table = union(table,row);
                tableID = tableID+1;
                }
        });
	y2milestone("table : %1", table);
        return table;
//      return tableitems;

};

// global define list sshContent()

global define list NodesTableContent()
{
	list ret = union( HPCControl::nodesIP(), HPCControl::nodesHPC() );
	return ret;
};




//-----------------------------------------------------------------
// collect information for Services Table
//-----------------------------------------------------------------

// Propose NFS-Directory
global define map NFSmap( string sharedir )
{
map ret = $[
	"mountpoint"	: sharedir,
	"hosts"		: "*",
	"options"	: "rw,root_squash,sync",
	];

return ret;
};

// Determine ssh-passwordless availibility

global define string SSHAvail ( string ipaddr )
{
	string ret = "notAvail";
	string command = ( "ssh -o BatchMode=yes "+ipaddr+" /tmp/testssh.sh");
	map output = (map)SCR::Execute(.target.bash_output, command);
	y2milestone("output from SSHAvail: %1",output);
	string stdout = (string)output["stdout"]:"blubb";
	y2milestone("command from SSHAvail: %1",command);
	if (stdout == "ssh_works\n")
	{
	ret = "Avail";
	}
	return ret;
};











}//end
