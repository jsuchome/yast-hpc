/**************
FILE          : HPCControl.ycp
***************
PROJECT       : YaST2 - Yet another Setup Tool
              :
AUTHOR        : Thomas Hofmann <thofmann@suse.de>
              :
BELONGS TO    : YaST2 - HPC Setup Module
              :
DESCRIPTION   : A module for setting up a HPC-Cluster-Scheduling System
              : with necessary environment
              :
STATUS        : Development
**************/
/*! \brief YaST2 - HPC interface (UI part)
*
* File:        HPCControl.ycp
* Package:     hpc Configuration
* Summary:     Main Module started if yast2 hpc is called
* Authors:     Thomas Hofmann <thofmann@suse.de>
*/
{ //begin
module "HPCControl";

textdomain "hpc";

import "Package";
import "Service";
import "Popup";
import "Wizard";
import "Progress";
import "HPCMessages";

//------------------------------------------
// check required Packages and install...
//------------------------------------------
global define any installPackages( list<string> requiredPacs )
``{
        return Package::InstallAllMsg (
                requiredPacs, HPCMessages::packagesmissing
        ) ? `auto : nil;
};



//---------------------------------------------
// check required services if running
//---------------------------------------------

global define boolean HPCServiceCheck( string service )
``{

        integer status = Service::Status ( service );
	// return true if service is running
        if ( status == 0 )
        {
	return true;
        }
	else return false;
};


//---------------------------------------------
// restart required services
//---------------------------------------------

global define boolean HPCServiceRestart( string service )
``{

        boolean start = Service::Restart ( service );

        // return true if service is running
        if ( start == true )
        {
        return true;
        }
        else return false;
};


//---------------------------------------------
// start required services
//---------------------------------------------

global define boolean HPCServiceStart( string service )
``{

        boolean start = Service::Start ( service );

	// return true if service is running
        if ( start == true )
        {
	return true;
        }
	else return false;
};


//-----------------------------------------------------------------
// load configure-file for MultiLineEdit - Scheduler Configuration
//-----------------------------------------------------------------

// Read Queue Configuration from QMGR

global define string HPCQueueConfig()
``{
	string qconfig = nil;

	if (SCR::Execute (.target.bash, "/opt/pbs/bin/qmgr -c \042 print server \042 > /tmp/queue.conf") == 0)
		{
		qconfig = (string)SCR::Read (.target.string, "/tmp/queue.conf");

		SCR::Execute (.target.bash, "rm -rf /tmp/queue.conf");
		}

	else
		{
		// qconfig = nil;

		}

	return qconfig;

};


// Read Scheduler Configuration from file

global define string HPCSchedConfig()
``{
	string schedconfig = nil;

	if (SCR::Execute (.target.bash, "/usr/bin/test -e /var/spool/pbs/sched_priv/sched_config") == 0)
		{
		schedconfig = (string)SCR::Read (.target.string, "/var/spool/pbs/sched_priv/sched_config");

//		y2milestone ("... sched_config read ...");
		}

//	else { y2milestone ("... reading failed ...");}

	return schedconfig;

};

// Write Scheduler Configuration from file

global define void HPCwriteSchedConfig( string configtext )
``{
        SCR::Write (.target.string, "/var/spool/pbs/sched_priv/sched_config", configtext);
        HPCControl::HPCServiceRestart("pbs_sched");
	//TODO  Return failed if service does not start
};


//-----------------------------------------------------------------
// detect Queue Properties
//-----------------------------------------------------------------

global define term queueTree()
{
	map OpenItemsMap = nil;
	list<string> OpenItems = nil;
	// Create a List of opened Items
        OpenItemsMap = (map)UI::QueryWidget(`id(`queues), `OpenItems);
        OpenItems = (list<string>)maplist(`k,`v, OpenItemsMap, {return k;});


	string init = "/usr/lib/YaST2/bin/detect_queues.sh init";
	SCR::Execute(.target.bash, init);
	string qcommand = "/usr/lib/YaST2/bin/detect_queues.sh config";
	map qoutput = (map)SCR::Execute(.target.bash_output, qcommand);
	string queues = (string)qoutput["stdout"]:"n.a.";

	y2milestone("+++++++++++++++Queues are: %1", queues);

	list<string> queuelist = (list<string>) splitstring(queues, "\n");

	queuelist = filter( string v, queuelist, { return (v != ""); });

	y2milestone("+++++++++++++++Queuelist is: %1", queuelist);

	list treeitems = [];
	list treeitem = [];
	foreach( string queue, queuelist, ``{

		// create queue-value-branch
		map valueinput = (map)SCR::Execute(.target.bash_output, "/usr/lib/YaST2/bin/detect_queues.sh queue "+queue);
		string values = (string)valueinput["stdout"]:"n.a.";
		list<string> valueslist = (list<string>) splitstring(values, "\n");
		valueslist = filter( string v, valueslist, { return (v != ""); });
		list valuesout = [];
		list valuesoutlist = [];

			foreach( string value, valueslist, ``{
			valuesout = [`item((string)value)
				    ];
			valuesoutlist = union(valuesoutlist,valuesout);
			});
		boolean Open = false;
		foreach(string OpenItem, OpenItems, ``{
		if (queue == OpenItem)
		{
		Open = true;
		}
		});
		treeitem = [`item((string)queue,valuesoutlist,Open)
			     ];
		treeitems = union(treeitems,treeitem);
		//treeitems = treeitem;
	});

	term tree = `Tree(`id(`queues),
				`opt(`notify),
					_("Select Queue:"),
				treeitems
			 );
	return tree;

};



//-----------------------------------------
// Query Queue Tree
//-----------------------------------------

global define string QueryTree(){

	string CurrentTreeItem = (string)UI::QueryWidget(`id(`queues), `CurrentItem);
	y2milestone("CurrentTreeItem: %1", CurrentTreeItem);
	if (issubstring(CurrentTreeItem,"="))
	{
		integer CurrentValuePos = findfirstof(CurrentTreeItem, "=");
		CurrentValuePos = CurrentValuePos+2;
		string CurrentValue = substring(CurrentTreeItem,CurrentValuePos);
		y2milestone("Currently selected TreeItem is: %1", CurrentTreeItem);
		y2milestone("Currently selected Value is: %1", CurrentValue);
		UI::ChangeWidget(`id(`savequeue), `Enabled, true);
		UI::ChangeWidget(`id(`queuevalue), `Value, CurrentValue);
		return CurrentValue;
	}
	else
	{
		UI::ChangeWidget(`id(`savequeue), `Enabled, false);
		UI::ChangeWidget(`id(`queuevalue), `Value, CurrentTreeItem);
		return CurrentTreeItem;
	}

};


//-----------------------------------------
// Refresh Queue Tree
//-----------------------------------------

global define void RefreshTree(){

	list WholeTree = (list)UI::QueryWidget(`id(`queues), `Items);
	map OpenItemsMap = (map)UI::QueryWidget(`id(`queues), `OpenItems);
	list OpenItems = maplist(`k,`v, OpenItemsMap, {return k;});
	y2milestone("CONTAINS: %1",contains( WholeTree,"test1"));
	y2milestone("OpenItens OUTPUT: %1",OpenItems);
	y2milestone("Whole Tree OUTPUT: %1",WholeTree);

};

//-----------------------------------------
// Append Tree Item
//-----------------------------------------

global define void AppendItem(string itemname){

	string CurrentTreeItem = (string)UI::QueryWidget(`id(`queues), `CurrentItem);
	        if (issubstring(CurrentTreeItem, "="))
	        {
		// yes This value is changeable
		string append = (string)UI::QueryWidget(`id(`queuevalue), `Value);
		y2milestone("Append to : %1", append );
		// determine root item
	        list<string> branch = (list<string>)UI::QueryWidget(`id(`queues), `CurrentBranch );
	        string CurrentQueuename = (string)select(branch,0," ");
		// kick last part of property item
	        integer position = findfirstof(CurrentTreeItem,"=");
	        string AppendQueueProperty = (string)substring(CurrentTreeItem,0,position);
		// change property
	        string qmgrappendcommand = "set queue "+CurrentQueuename+" "+AppendQueueProperty+" = "+append;
	        map appenderrormap = (map)SCR::Execute(.target.bash_output,"/opt/pbs/bin/qmgr -c \""+qmgrappendcommand+"\"");
		string appenderror = (string)appenderrormap["stderr"]:"error";

			if (appenderror == "")
			{
			RefreshTree();
		        term newtree = queueTree();
		        UI::ReplaceWidget(`id(`TreeDialog), newtree);
		        HPCServiceRestart("pbs_server");
			}
			else
			{
			Popup::AnyMessage("Error", appenderror);
			}
		}
};


//-----------------------------------------
// Add Tree Item
//-----------------------------------------

global define void AddItem(string itemname){

	string CurrentTreeItem = (string)UI::QueryWidget(`id(`queues), `CurrentItem);
	if (issubstring(CurrentTreeItem, "="))
	{
	// is a queue Item
	y2milestone("Add a QueueItem");

	list<string> branch = (list<string>)UI::QueryWidget(`id(`queues), `CurrentBranch );
        string CurrentQueuename = (string)select(branch,0," ");
        integer position = findfirstof(CurrentTreeItem,"=");
        string DeleteQueueProperty = (string)substring(CurrentTreeItem,0,position);
        string qmgrdeletecommand = "unset queue "+CurrentQueuename+" "+DeleteQueueProperty;

	UI::OpenDialog(
                        `VBox(
                                `Label("Add new property to queue "+CurrentQueuename),
                                `TextEntry(`id(`newqueueproperty), "Enter Property :"),
                                `VSpacing(1),
                                `HBox(
                                        `PushButton(`id(`AddQueuePropCancel),"cancel"),
                                        `PushButton(`id(`AddQueuePropOK),"OK")
                                     )
                             )
                      );
        any ret = UI::UserInput();
	string newqueueprop = (string)UI::QueryWidget(`id(`newqueueproperty), `Value);
	UI::CloseDialog();

	if ( ret == `AddQueuePropOK)
		{
		y2milestone("-------------YES, there is a new property: %1",newqueueprop);
		string setnewprop = "/opt/pbs/bin/qmgr -c \"set queue "+CurrentQueuename+" "+newqueueprop+"\"";
		map qmgrout = (map)SCR::Execute(.target.bash_output, setnewprop);
		string qmgrerror = (string)qmgrout["stderr"]:"error";
		y2milestone("---------------qmgrerror is %1:",qmgrerror);
		if (qmgrerror == "")
			{
			term newtree = queueTree();
			UI::ReplaceWidget(`id(`TreeDialog), newtree);
			HPCServiceRestart("pbs_server");
			}
		else
			{
			Popup::AnyMessage("Error", qmgrerror);
			}
		}


	}
	else
	{
	// is a whole queue
	y2milestone("Add a whole Queue");

	UI::OpenDialog(
			`VBox(
				`Label("Add new queue"),
				`TextEntry(`id(`newqueuename), "Enter Queue Name:"),
				`VSpacing(1),
				`HBox(
					`PushButton(`id(`AddQueueCancel),"cancel"),
					`PushButton(`id(`AddQueueOK),"OK")
				     )
			     )
		      );
	any ret = UI::UserInput();
	string newqueuename = (string)UI::QueryWidget(`id(`newqueuename), `Value);
	UI::CloseDialog();
		if ( ret == `AddQueueOK)
		{
		y2milestone("-------------YES, there is a new queue name: %1",newqueuename);
		string addnewqueuecommand = "/opt/pbs/bin/qmgr -c \"create queue "+newqueuename+"\"";
		string setnewqueueexec = "/opt/pbs/bin/qmgr -c \"set queue "+newqueuename+" queue_type=Execution\"";
		string setnewqueuekdelay = "/opt/pbs/bin/qmgr -c \"set queue "+newqueuename+" kill_delay=20\"";
		string setnewqueueenabled = "/opt/pbs/bin/qmgr -c \"set queue "+newqueuename+" enabled=true\"";
		string setnewqueuestarted = "/opt/pbs/bin/qmgr -c \"set queue "+newqueuename+" started=true\"";
		SCR::Execute(.target.bash, addnewqueuecommand);
		SCR::Execute(.target.bash, setnewqueueexec);
		SCR::Execute(.target.bash, setnewqueuekdelay);
		SCR::Execute(.target.bash, setnewqueueenabled);
		SCR::Execute(.target.bash, setnewqueuestarted);
		term newtree = queueTree();
		UI::ReplaceWidget(`id(`TreeDialog), newtree);
		HPCServiceRestart("pbs_server");
		}
	}
};

//-----------------------------------------
// Delete Tree Item
//-----------------------------------------

global define void DeleteItem(string itemname){

        string CurrentTreeItem = (string)UI::QueryWidget(`id(`queues), `CurrentItem);
        if (issubstring(CurrentTreeItem,"="))
	{
	// is a queue Item
	list<string> branch = (list<string>)UI::QueryWidget(`id(`queues), `CurrentBranch );
	string CurrentQueuename = (string)select(branch,0," ");
	integer position = findfirstof(CurrentTreeItem,"=");
	string DeleteQueueProperty = (string)substring(CurrentTreeItem,0,position);
	string qmgrdeletecommand = "unset queue "+CurrentQueuename+" "+DeleteQueueProperty;
	SCR::Execute(.target.bash,"/opt/pbs/bin/qmgr -c \""+qmgrdeletecommand+"\"");
	term newtree = queueTree();
	UI::ReplaceWidget(`id(`TreeDialog), newtree);
	HPCServiceRestart("pbs_server");
	}
	else
	{
		// is a queue
		y2milestone("Delete a whole Queue");
		// Warning before deletion
		boolean deletequeue = Popup::ContinueCancel(HPCMessages::deletequeuequestion);
		if (deletequeue == true)
		{
			map output = (map)SCR::Execute(.target.bash_output, "/opt/pbs/bin/qmgr -c \" delete queue "+itemname+"\"");
			string errormessage = (string)output["stderr"]:"";
			if ( errormessage == "" )
			{
				term newtree = queueTree();
				UI::ReplaceWidget(`id(`TreeDialog), newtree);
				HPCServiceRestart("pbs_server");
			}
			else
			{	// Error Message if queue can't be deleted
				Popup::AnyMessage("Error", (string)output["stderr"]:"An error occured");
				y2milestone("+++++++Error-LOOP");
			}
		}
	}

};


//-----------------------------------------
// Check if User made changes
//-----------------------------------------

global define boolean have_changes_check()
{
	boolean status = true; //dummy value
	// TODO: do a real check if there were changes!
        return status;
};


//-----------------------------------------------------------------
// collect information about nodes via bash-script
//-----------------------------------------------------------------

// Collect information by querying IPs
//---------------------------------------

// get name from IP
global define string name(any ip)
{
	string command = ("/usr/lib/YaST2/bin/nodes.sh name "+(string)ip);
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"n.a.", "}\n" );
	return ret;
};

// determine if computer is member of cluster
global define string clusternode(string resname)
{
	string command = ("/usr/lib/YaST2/bin/nodes.sh clusternode "+resname);
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"n.a.", "\n" );
	return ret;
};

// get number of cpus of node $
global define string cpus(string resname)
{
	string command = "/usr/lib/YaST2/bin/nodes.sh cpus "+resname;
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"n.a.", "\n" );
	return ret;

};

// get status of node
global define string status(string resname)
{
	string command = "/usr/lib/YaST2/bin/nodes.sh status "+resname;
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars( (string)output["stdout"]:"not reachable", "\n" );
	return ret;
};



// Collect information by querying 'pbsnodes -a'
//----------------------------------------------

// get status of node
global define string ipaddress(string resname)
{
	string command = "/usr/lib/YaST2/bin/nodes.sh ip "+resname;
	map output = (map) SCR::Execute(.target.bash_output, command);
	string ret = deletechars(  (string)output["stdout"]:"n.a.", "\n" );
	return ret;
};

// Determine ssh-passwordless availibility

global define string SSHAvail ( string ipaddr )
{
	string ret = "no";
	string command = ( "ssh -o BatchMode=yes "+ipaddr+" echo $HOSTNAME");
	map output = (map)SCR::Execute(.target.bash_output, command);
	y2milestone("output from SSHAvail: %1",output);
	integer exit = output["exit"]:255;
	y2milestone("exit: %1",exit);
	if (exit == 0)
	{
	ret = "yes";
	}
	return ret;
};

// detect currently selected table-item

global define string tableItem(symbol column){
	integer itemid = (integer)UI::QueryWidget(`id(`nodestable), `CurrentItem);
        string itemstring = tostring(UI::QueryWidget(`id(`nodestable), `Item(itemid)));
        list<string> itemlist = splitstring(itemstring, "\"");

//        y2milestone("ITEMSTRING: %1", itemstring);
	string ret = "";

        if (column == `ip)
	{
	ret = (string)select(itemlist,1,"error");
//      y2milestone("tableItem IP: %1", ret);
	}

        if (column == `cluster)
	{
	ret = (string)select(itemlist,3,"error");
//        y2milestone("tableItem IP: %1", ret);
	}

	if (column == `node)
	{
//	y2milestone("ITEMLIST: %1",itemlist);
	ret = (string)select(itemlist,5,"error");
//	y2milestone("tableItem node: %1", ret);
	}

	if (column == `ssh)
	{
	ret = (string)select(itemlist,11,"error");
//        y2milestone("tableItem IP: %1", ret);
	}
//	y2milestone("tableItem Return value = %1", ret);
	return ret;

};


// deploy ssh-public key

global define list SSHcopy () //( string ipaddr )
{
	string node = tableItem(`node);
	string ip = tableItem(`ip);
//	y2milestone("IP by tableitem is: %1", ip);
	string command = ("/usr/bin/ssh-copy-id -i /root/.ssh/id_rsa.pub root@"+node);
	SCR::Execute(.target.bash,command);
	// Line in nodes-Tab should is redetected
	integer currentitem = (integer)UI::QueryWidget(`id(`nodestable), `CurrentItem);
	UI::ChangeWidget(`id(`nodestable), `Item(currentitem, 5), SSHAvail(ip) );
	list newcontent = (list)UI::QueryWidget(`id(`nodestable), `Items);
	return newcontent;
};


// add node to cluster

global define list AddClusterNode(){
	string node = tableItem(`node);
	// popup-warning
	boolean addcontinue = Popup::ContinueCancel (HPCMessages::sshsecuritywarning);
	if (addcontinue == true)
	{
		// enable nis-hosts in /etc/nsswitch.conf
		string scpnsswitch = "/usr/bin/scp /usr/lib/YaST2/bin/nsswitch.patch root@"+node+":/tmp/ ";
		string patchnsswitch = "/usr/bin/ssh root@"+node+" patch /etc/nsswitch.conf /tmp/nsswitch.patch";
		// & restart nscd on node
		string nscdrestart = "/usr/bin/ssh root@"+node+" rcnscd restart";
		SCR::Execute(.target.bash, scpnsswitch);
		SCR::Execute(.target.bash, patchnsswitch);
		SCR::Execute(.target.bash, nscdrestart);
		// copy installscript to location where root can execut it (nfs is mounted root_squash !)
		string installcopycommand = "/usr/bin/ssh root@"+node+" cp /hpc$( grep SHAREPOINT /etc/sysconfig/hpc.cfg|cut -f2 -d\":\" )/install.sh /tmp/ ";
		// execute install script
		string installcommand = "/usr/bin/ssh root@"+node+" /tmp/install.sh";
		SCR::Execute(.target.bash, installcopycommand);
		SCR::Execute(.target.bash, installcommand);
		string numofcpus = tostring(UI::QueryWidget(`id(`CPUs), `Value));
		y2milestone("Number of CPUs: %1", numofcpus);
		string addnodecommand = "echo -e \""+node+"\\t np="+numofcpus+"\" >> /var/spool/pbs/server_priv/nodes";
		y2milestone("Command for pasting into nodes-file: %1",addnodecommand);
		SCR::Execute(.target.bash,addnodecommand);
		// Restart PBS-Service
		HPCServiceRestart("pbs_server");
	}
	// Line in nodes-Tab should be redetected
	integer currentitem = (integer)UI::QueryWidget(`id(`nodestable), `CurrentItem);
	UI::ChangeWidget(`id(`nodestable), `Item(currentitem, 1), clusternode(node));
	UI::ChangeWidget(`id(`nodestable), `Item(currentitem, 3), cpus(node));
	UI::ChangeWidget(`id(`nodestable), `Item(currentitem, 4), status(node));
	// Changed Value to be written in tab-list
        list newcontent = (list)UI::QueryWidget(`id(`nodestable), `Items);
	return newcontent;

};


// Remove node from cluster

global define list RemoveClusterNode(){
	string node = tableItem(`node);
	string command = "/usr/bin/ssh -l root "+node+" rpm -e OpenPBS OpenPBS-mom ";
	SCR::Execute(.target.bash,command);
	string removecommand = "sed '/"+node+"/d' /var/spool/pbs/server_priv/nodes > /tmp/nodes.tmp";
	SCR::Execute(.target.bash, removecommand);
	SCR::Execute(.target.bash, "mv /tmp/nodes.tmp /var/spool/pbs/server_priv/nodes");
        HPCServiceRestart("pbs_server");

	// Line in nodes-Tab should be redetected
	integer currentitem = (integer)UI::QueryWidget(`id(`nodestable), `CurrentItem);
        UI::ChangeWidget(`id(`nodestable), `Item(currentitem, 1), clusternode(node));
        UI::ChangeWidget(`id(`nodestable), `Item(currentitem, 3), cpus(node));
        UI::ChangeWidget(`id(`nodestable), `Item(currentitem, 4), status(node));
        // Changed Value to be written in tab-list
        list newcontent = (list)UI::QueryWidget(`id(`nodestable), `Items);
        return newcontent;
};

// Disable / Enable Buttons in nodes Tab

global define void Buttonstate(){

	// if ssh = yes then disable obtainSSH-Button else enable it!
	if ( tableItem(`ssh) == "yes")
	{
		UI::ChangeWidget(`id(`copyssh), `Enabled, false);
		// if cluster-node = no then disable "remove from cluster" & enable "add to cluster" else <->
		if (tableItem(`cluster) == "yes")
		{
		UI::ChangeWidget(`id(`addnode), `Enabled, false);
		UI::ChangeWidget(`id(`remnode), `Enabled, true);
		}
		else
		{
		UI::ChangeWidget(`id(`addnode), `Enabled, true);
		UI::ChangeWidget(`id(`remnode), `Enabled, false);
		}

	}
	else
	{
	UI::ChangeWidget(`id(`addnode), `Enabled, false);
        UI::ChangeWidget(`id(`remnode), `Enabled, false);
	UI::ChangeWidget(`id(`copyssh), `Enabled, true);
	}
};



//-----------------------------------------------------------------
// detect Content of Nodes Table
//-----------------------------------------------------------------

global define list allIPs()
{
	string broadcast = "/usr/lib/YaST2/bin/nodes.sh broadcast";
	string nodecast = "/usr/lib/YaST2/bin/nodes.sh getclusternodes";
	map broadout = (map) SCR::Execute(.target.bash_output, broadcast);
	map nodeout = (map) SCR::Execute(.target.bash_output, nodecast);

	string broadIP = (string) broadout["stdout"]:"error";
	list broadIPlist = (list) splitstring(broadIP,"\n");

	string nodes = (string) nodeout["stdout"]:"error";
	list<string> nodelist = splitstring(nodes,"\n");
	list nodeIPlist = [];
	foreach(string node, nodelist, ``{
			if (node != "")
			{
				list ip = [ipaddress(node)];
				nodeIPlist = union(nodeIPlist, ip);
			}
		});
	list all = union(broadIPlist, nodeIPlist);
//	y2milestone("IPliste aus allIPs: %1", all);
	return all;
};



global define list nodes()
{
// TODO: in case of error: should return Label "No PBS detected" or something lk that

//------------------------------------------
// collect node information
//------------------------------------------
	string window_title = _("Collecting Nodes information");     // window title
	string progress_title = _(" ");                        // progress title
	integer length = 2;                              // length
	list<string> stages = [
	// progress stage, text in dialog (short) (infinitive)
	_("Collect node information"),
	];
	list<string> titles = [
	// progress step, text in dialog (short)
        _("Collecting node information..."),
        ];
        string help = _("progress help text");
	Progress::New(
                                window_title,
                                progress_title,
                                length,
                                stages,
                                titles,
                                help
                );

	Progress::NextStage();


        list iplist = allIPs();

        list table = [];
	integer tableID = 1;
        foreach(any ip, iplist, ``{
                if (ip != "")
		{
			string cname = name(ip);
			list row = [
					`item(`id(tableID),
					ip,
					clusternode(cname),
					cname,
					cpus(cname),
					status(cname),
					SSHAvail((string)ip)
				)];
			table = union(table,row);
			tableID = tableID + 1;
		}
        });
        y2milestone("table : %1", table);

                 if (table == nil)
                        {
                        UI::OpenDialog(
                                        `VBox(  `Label(HPCMessages::nohostsdetected),
                                               `PushButton(_("&Abort Installation"))
                                              )
                                        );
                        UI::UserInput();
                        UI::CloseDialog();
                        return nil;
                        };
                Progress::Finish();


        return table;
//      return tableitems;

};


//-----------------------------------------------------------------
// collect information for NFS/NIS-Maps - Services
//-----------------------------------------------------------------

// Propose NFS-Directory
global define void NFSmap( map nfs, map nfsnew )
{
	string mountpoint = nfs["mountpoint"]:"";
	string homepoint = nfs["homepoint"]:"";
	string hosts = nfs["hosts"]:"";
	string hhosts = nfs["hhosts"]:"";
	string options = nfs["options"]:"";
	string hoptions = nfs["hoptions"]:"";

	string nmountpoint = nfsnew["mountpoint"]:"";
	string nhomepoint = nfsnew["homepoint"]:"";
	string nhosts = nfsnew["hosts"]:"";
	string nhhosts = nfsnew["hhosts"]:"";
	string noptions = nfsnew["options"]:"";
	string nhoptions = nfsnew["hoptions"]:"";

	if ( (mountpoint != nmountpoint) || (hosts != nhosts) || (options != noptions) || (SCR::Read(.target.string,"/etc/auto.hpc")==nil) )
	{
	// remove old mountpoint
	SCR::Execute(.target.bash,"sed '/SHAREPOINT/d' /etc/sysconfig/hpc.cfg > /tmp/hpc.tmp");
	SCR::Execute(.target.bash,"mv /tmp/hpc.tmp /etc/sysconfig/hpc.cfg");
	// mark new mountpoint in hpc.cfg
	string command = "echo \042SHAREPOINT:"+nmountpoint+":"+nhosts+":"+noptions+"\042 >> /etc/sysconfig/hpc.cfg";
        SCR::Execute(.target.bash, command);
	// remove old / write new mountpoint to nfs config
	string command2 = "/sbin/yast2 nfs_server delete mountpoint="+mountpoint;
	SCR::Execute(.target.bash,command2);
	string command3 = "/sbin/yast2 nfs_server add mountpoint="+nmountpoint+" hosts="+nhosts+" options="+noptions;
	SCR::Execute(.target.bash, command3 );
	// remove old / write new mountpoint to auto.hpc nis map
	SCR::Execute(.target.bash, ("sed '/"+mountpoint+"/d' /etc/auto.hpc > /tmp/auto.hpc.tmp"));
	SCR::Execute(.target.bash, ("mv /tmp/auto.hpc.tmp /etc/auto.hpc"));
	string nmountpointdir = substring(nmountpoint,1); // remove "/" from nmountpoint
	string mapcommand = "echo -e \042"+nmountpointdir+"\t-fstype=nfs,rw,rsize=8192,wsize=8192,hard,intr,nolock,nosuid\t\t $HOST:"+nmountpoint+"\042 >> /etc/auto.hpc";
	SCR::Execute(.target.bash, mapcommand);
	}

//	if ( (homepoint != nhomepoint) || (hhosts != nhhosts) || (hoptions != nhoptions) || (SCR::Read(.target.string,"/etc/auto.home")==nil) )
	{
	// remove old /home mountpoint
	SCR::Execute(.target.bash,"sed '/HOMEPOINT/d' /etc/sysconfig/hpc.cfg > /tmp/hpc.tmp");
	SCR::Execute(.target.bash,"mv /tmp/hpc.tmp /etc/sysconfig/hpc.cfg");
	// mark new /home mountpoint in hpc.cfg
        SCR::Execute(.target.bash,"echo \042HOMEPOINT:"+nhomepoint+":"+nhhosts+":"+nhoptions+"\042 >> /etc/sysconfig/hpc.cfg");
	//remove old / write new mountpoint to nfs config
	SCR::Execute(.target.bash,"/sbin/yast2 nfs_server delete mountpoint="+homepoint );
	SCR::Execute(.target.bash,"/sbin/yast2 nfs_server add mountpoint="+nhomepoint+" hosts="+nhhosts+" options="+nhoptions );
	// create new nis maps for /home
	SCR::Execute(.target.bash,"/usr/lib/YaST2/bin/mergemaps.sh "+nhomepoint);
	}


};


// Query NFS-Settings & write config-file
global define map QuerynWriteNFSsettings(map nfs){

	// Query NFS settings
	map nfsnew = $[
                "mountpoint": (string)UI::QueryWidget(`id(`mountpoint), `Value),
                "hosts": (string)UI::QueryWidget(`id(`hosts), `Value),
                "options": (string)UI::QueryWidget(`id(`options), `Value),
                "homepoint": (string)UI::QueryWidget(`id(`homepoint), `Value),
                "hhosts": (string)UI::QueryWidget(`id(`hhosts), `Value),
                "hoptions": (string)UI::QueryWidget(`id(`hoptions), `Value)
                                ];
	string window_title = _("Writing NFS Data");     // window title
	                string progress_title = _(" ");                        // progress title
	                integer length = 2;                              // length
	                list<string> stages = [
	                    // progress stage, text in dialog (short) (infinitive)
	                    _("Write NFS Data"),
	                    _("Restart NFS-Server"),
	                 ];
	                list<string> titles = [
	                    // progress step, text in dialog (short)
	                    _("Writing NFS Data ..."),
	                    _("Restarting NFS-Server ..."),
	                 ];
	                string help = _("progress help text");
	                Progress::New(
	                                window_title,
	                                progress_title,
	                                length,
	                                stages,
	                                titles,
	                                help
	                );
	                Progress::NextStage();
			NFSmap(nfs,nfsnew);

			 // NFS-SERVER RESTART

	                HPCServiceRestart( "nfsserver" );

	                Progress::Finish();

		return nfsnew;
};

//-----------------------------------------------------------------
// Firewall Ports
//-----------------------------------------------------------------

global define term FWsettings(boolean FirewallOn)
{
	term firewallsettings = nil;

        if (FirewallOn == false)
        {
        firewallsettings = `VBox(       `CheckBox(`id(`firewall),`opt(`disabled), _("Open Ports in Firewall"), false),
                                        `Label(_("Firewall is disabled"))
                                );
        }
        else
        {
        firewallsettings = `VBox(  `CheckBox(`id(`firewall), _("Open Ports in Firewall"), true),
                                        `Label(_("Firewall enabled"))
                                );
        }
	return firewallsettings;

};


global define void OpenFWPorts()
{
	SCR::Execute(.target.bash,"/sbin/yast2 firewall services add tcpport=15001:15004 zone=INT" );
	SCR::Execute(.target.bash,"/sbin/yast2 firewall services add udpport=15003 zone=INT" );
	SCR::Execute(.target.bash,"/sbin/yast2 firewall services add service=nfs-server zone=INT" );
	SCR::Execute(.target.bash,"/sbin/yast2 firewall services add service=nis-server zone=INT" );
	SCR::Execute(.target.bash,"/sbin/yast2 firewall services add service=ntp-server zone=INT" );
	SCR::Execute(.target.bash,"/sbin/yast2 firewall services add service=ssh zone=INT" );
};




}//end
